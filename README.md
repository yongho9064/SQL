# 📝 SQL 주요 팁 및 리마인드

개발 과정에서 자주 잊거나 SQL 관련 팁을 정리한다.

## 1. 대량의 행 데이터 삭제: `DELETE` vs. `TRUNCATE`

테이블의 모든 행을 삭제할 때는 `DELETE` 대신 `TRUNCATE` 사용을 권장한다.

```sql
TRUNCATE TABLE table_name;
```

### 왜 `TRUNCATE`를 사용해야 하는가?

- **속도**: `TRUNCATE`는 `DELETE`보다 훨씬 빠르다. `DELETE`는 각 행을 개별적으로 삭제하고 로그를 남기지만, `TRUNCATE`는 테이블 구조만 남기고 데이터가 차지하던 공간을 바로 해제하기 때문이다.
- **자원**: 데이터의 양이 많을수록 `DELETE`는 시스템에 큰 부하를 주지만, `TRUNCATE`는 훨씬 적은 리소스를 사용한다.

> 📌 **핵심**: 삭제할 데이터가 많을수록 `TRUNCATE`와 `DELETE`의 성능 차이는 더욱 커진다.

<br>

## 2. 문자형 데이터 타입: `CHAR` vs. `VARCHAR`

`CHAR`와 `VARCHAR`는 가장 기본적인 문자형 데이터 타입이다. 두 타입의 특징을 이해하고 상황에 맞게 사용하는 것이 중요하다.

| 데이터 형식       | 최대 크기     | 특징                       |
| --------------- | ------------- | -------------------------- |
| **`CHAR(n)`**   | 255 바이트    | **고정 길이** 문자형       |
| **`VARCHAR(n)`** | 65,535 바이트 | **가변 길이** 문자형       |

### `CHAR`: 고정 길이 문자형

- 지정된 길이(`n`)만큼 공간을 항상 차지한다.
- 예를 들어 `CHAR(10)`에 'SQL' (3바이트)을 저장해도, 나머지 7바이트는 공백으로 채워져 **10바이트** 공간을 모두 사용한다.
- **사용 시점**: 주민등록번호, MD5 해시값 등 **글자 수가 항상 고정된 데이터**에 사용하는 것이 효율적이다.

### `VARCHAR`: 가변 길이 문자형

- 실제 저장되는 데이터의 길이에 따라서만 공간을 차지한다.
- 예를 들어 `VARCHAR(10)`에 'SQL' (3바이트)을 저장하면 **3바이트**의 공간만 사용한다. (길이 정보 저장을 위한 약간의 추가 공간은 별도)
- **사용 시점**: 이름, 주소, 게시글 제목 등 **글자 수가 유동적인 데이터**에 적합하다.

> 💡 **성능에 대한 참고**
>
> `VARCHAR`는 공간 효율성이 뛰어나지만, MySQL 내부적으로는 `CHAR` 타입이 약간의 성능상 이점을 가질 수 있다. 이는 고정 길이 데이터의 빠른 탐색 덕분이다. 하지만 대부분의 경우 그 차이는 미미하므로, 데이터의 특성에 맞게 선택하는 것이 우선이다.

<br>

## 3. 숫자처럼 보이지만 문자형으로 다뤄야 하는 데이터

데이터가 숫자로만 구성되어 있더라도, **숫자로서의 의미가 없다면** 문자형(`CHAR`, `VARCHAR`)으로 지정하는 것이 **좋다**.

'숫자로서의 의미'는 아래 두 조건 중 하나 이상을 충족해야 한다.

1.  **더하기, 빼기 등 산술 연산**에 의미가 있는가? (예: 수량, 가격, 점수)
2.  **크고 작음을 비교하거나 순서**에 의미가 있는가? (예: 나이, 키, 순위)

위 조건에 해당하지 않는다면 문자형으로 다루는 것이 올바르다.

> **예시**:
>
> - **전화번호**: `010-1234-5678`. 덧셈이나 크기 비교가 무의미하며, 맨 앞의 `0`이 보존되어야 한다.
> - **우편번호**: `06134`. 연산의 대상이 아니며, `0`으로 시작할 수 있다.
> - **주민등록번호**: `900101-1234567`. 단순한 식별자일 뿐, 수학적 의미가 **없다**.

## 4. 대량의 데이터 형식

### `LONGTEXT`: 42억까지 글자를 저장할 수 있는 데이터 형식

- 소설이나 영화 대본과 같은 내용을 저장할 때 사용

### `LONGBLOB`: 42억까지 바이트를 저장할 수 있는 데이터 형식

- 사진이나 동영상과 같은 것을 저장하고 싶다면 `BlOB`나 `LONGBLOB`을 사용

## 5. 기타 조인

### 1. 상호 조인 (CROSS JOIN)

한쪽 테이블의 모든 행을 다른 쪽 테이블의 모든 행과 조인하는 기능이다. 결과 집합의 크기는 두 테이블의 행 개수를 곱한 값과 같으며, 이를 `카티션 곱(Cartesian Product)`이라고도 부른다.

#### 특징
- `ON` 절을 사용하지 않는다.
- 결합된 데이터 자체가 특정 관계를 의미하지는 않으므로, 주로 대용량 테스트 데이터를 생성하는 목적으로 사용된다.

#### 구문
```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

**예시: `buy` 테이블과 `member` 테이블의 모든 가능한 조합을 조회**
```sql
SELECT * FROM buy CROSS JOIN member;
```

<br>

### 2. 자체 조인 (SELF JOIN)

하나의 테이블을 자기 자신과 조인하는 기능이다. 별도의 키워드 없이, 한 테이블에 서로 다른 `별칭(Alias)`을 부여하여 조인하는 방식으로 구현한다.

주로 하나의 테이블 내에 계층적 관계(예: 직원과 관리자, 부모 카테고리와 자식 카테고리)가 존재할 때 사용된다.

#### 구문
```sql
SELECT A.column, B.column
FROM table_name A
JOIN table_name B ON A.related_column = B.key_column;
```

**예시: `emp_table`에서 '경리부장'의 직속 상관 정보 조회**
```sql
SELECT
    A.emp AS "직원",
    B.emp AS "직속상관",
    B.phone AS "직속상관연락처"
FROM
    emp_table A
INNER JOIN
    emp_table B ON A.manager = B.emp
WHERE
    A.emp = '경리부장';
```
> 위 예시에서 `A`는 직원을, `B`는 직속 상관을 나타내는 동일한 `emp_table`이다. `A.manager` (직원의 관리자 ID)와 `B.emp` (관리자의 직원 ID)를 연결하여 관계를 파악한다.

