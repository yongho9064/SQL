# 📝 SQL 주요 팁 및 리마인드

개발 과정에서 자주 잊거나 SQL 관련 팁을 정리한다.

## 1. 대량의 행 데이터 삭제: `DELETE` vs. `TRUNCATE`

테이블의 모든 행을 삭제할 때는 `DELETE` 대신 `TRUNCATE` 사용을 권장한다.

```sql
TRUNCATE TABLE table_name;
```

### 왜 `TRUNCATE`를 사용해야 하는가?

- **속도**: `TRUNCATE`는 `DELETE`보다 훨씬 빠르다. `DELETE`는 각 행을 개별적으로 삭제하고 로그를 남기지만, `TRUNCATE`는 테이블 구조만 남기고 데이터가 차지하던 공간을 바로 해제하기 때문이다.
- **자원**: 데이터의 양이 많을수록 `DELETE`는 시스템에 큰 부하를 주지만, `TRUNCATE`는 훨씬 적은 리소스를 사용한다.

> 📌 **핵심**: 삭제할 데이터가 많을수록 `TRUNCATE`와 `DELETE`의 성능 차이는 더욱 커진다.

<br>

## 2. 문자형 데이터 타입: `CHAR` vs. `VARCHAR`

`CHAR`와 `VARCHAR`는 가장 기본적인 문자형 데이터 타입이다. 두 타입의 특징을 이해하고 상황에 맞게 사용하는 것이 중요하다.

| 데이터 형식       | 최대 크기     | 특징                       |
| --------------- | ------------- | -------------------------- |
| **`CHAR(n)`**   | 255 바이트    | **고정 길이** 문자형       |
| **`VARCHAR(n)`** | 65,535 바이트 | **가변 길이** 문자형       |

### `CHAR`: 고정 길이 문자형

- 지정된 길이(`n`)만큼 공간을 항상 차지한다.
- 예를 들어 `CHAR(10)`에 'SQL' (3바이트)을 저장해도, 나머지 7바이트는 공백으로 채워져 **10바이트** 공간을 모두 사용한다.
- **사용 시점**: 주민등록번호, MD5 해시값 등 **글자 수가 항상 고정된 데이터**에 사용하는 것이 효율적이다.

### `VARCHAR`: 가변 길이 문자형

- 실제 저장되는 데이터의 길이에 따라서만 공간을 차지한다.
- 예를 들어 `VARCHAR(10)`에 'SQL' (3바이트)을 저장하면 **3바이트**의 공간만 사용한다. (길이 정보 저장을 위한 약간의 추가 공간은 별도)
- **사용 시점**: 이름, 주소, 게시글 제목 등 **글자 수가 유동적인 데이터**에 적합하다.

> 💡 **성능에 대한 참고**
>
> `VARCHAR`는 공간 효율성이 뛰어나지만, MySQL 내부적으로는 `CHAR` 타입이 약간의 성능상 이점을 가질 수 있다. 이는 고정 길이 데이터의 빠른 탐색 덕분이다. 하지만 대부분의 경우 그 차이는 미미하므로, 데이터의 특성에 맞게 선택하는 것이 우선이다.

<br>

## 3. 숫자처럼 보이지만 문자형으로 다뤄야 하는 데이터

데이터가 숫자로만 구성되어 있더라도, **숫자로서의 의미가 없다면** 문자형(`CHAR`, `VARCHAR`)으로 지정하는 것이 **좋다**.

'숫자로서의 의미'는 아래 두 조건 중 하나 이상을 충족해야 한다.

1.  **더하기, 빼기 등 산술 연산**에 의미가 있는가? (예: 수량, 가격, 점수)
2.  **크고 작음을 비교하거나 순서**에 의미가 있는가? (예: 나이, 키, 순위)

위 조건에 해당하지 않는다면 문자형으로 다루는 것이 올바르다.

> **예시**:
>
> - **전화번호**: `010-1234-5678`. 덧셈이나 크기 비교가 무의미하며, 맨 앞의 `0`이 보존되어야 한다.
> - **우편번호**: `06134`. 연산의 대상이 아니며, `0`으로 시작할 수 있다.
> - **주민등록번호**: `900101-1234567`. 단순한 식별자일 뿐, 수학적 의미가 **없다**.

## 4. 대량의 데이터 형식

### `LONGTEXT`: 42억까지 글자를 저장할 수 있는 데이터 형식

- 소설이나 영화 대본과 같은 내용을 저장할 때 사용

### `LONGBLOB`: 42억까지 바이트를 저장할 수 있는 데이터 형식

- 사진이나 동영상과 같은 것을 저장하고 싶다면 `BlOB`나 `LONGBLOB`을 사용

## 5. 기타 조인

### 1. 상호 조인 (CROSS JOIN)

한쪽 테이블의 모든 행을 다른 쪽 테이블의 모든 행과 조인하는 기능이다. 결과 집합의 크기는 두 테이블의 행 개수를 곱한 값과 같으며, 이를 `카티션 곱(Cartesian Product)`이라고도 부른다.

#### 특징
- `ON` 절을 사용하지 않는다.
- 결합된 데이터 자체가 특정 관계를 의미하지는 않으므로, 주로 대용량 테스트 데이터를 생성하는 목적으로 사용된다.

#### 구문
```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

**예시: `buy` 테이블과 `member` 테이블의 모든 가능한 조합을 조회**
```sql
SELECT * FROM buy CROSS JOIN member;
```

<br>

### 2. 자체 조인 (SELF JOIN)

하나의 테이블을 자기 자신과 조인하는 기능이다. 별도의 키워드 없이, 한 테이블에 서로 다른 `별칭(Alias)`을 부여하여 조인하는 방식으로 구현한다.

주로 하나의 테이블 내에 계층적 관계(예: 직원과 관리자, 부모 카테고리와 자식 카테고리)가 존재할 때 사용된다.

#### 구문
```sql
SELECT A.column, B.column
FROM table_name A
JOIN table_name B ON A.related_column = B.key_column;
```

**예시: `emp_table`에서 '경리부장'의 직속 상관 정보 조회**
```sql
SELECT
    A.emp AS "직원",
    B.emp AS "직속상관",
    B.phone AS "직속상관연락처"
FROM
    emp_table A
INNER JOIN
    emp_table B ON A.manager = B.emp
WHERE
    A.emp = '경리부장';
```
> 위 예시에서 `A`는 직원을, `B`는 직속 상관을 나타내는 동일한 `emp_table`이다. `A.manager` (직원의 관리자 ID)와 `B.emp` (관리자의 직원 ID)를 연결하여 관계를 파악한다.

## 6. CASCADE 옵션
`CASCADE` 옵션은 외래 키 제약 조건을 설정할 때 사용되며, 부모 테이블의 행이 삭제되거나 업데이트될 때 자식 테이블의 행도 자동으로 삭제하거나 업데이트하는 기능을 제공한다.
```sql
CREATE TABLE buy (
    id INT PRIMARY KEY,
    member_id INT,
    FOREIGN KEY (member_id) REFERENCES member(id) 
        ON DELETE CASCADE 
        ON UPDATE CASCADE
);
```

## 7. View

### 뷰를 사용하는 이유?

* 뷰는 실제 테이블의 데이터를 숨기고, 필요한 데이터만을 보여준다. 
  * 예를 들어 회원의 개인 정보를 포함하는 테이블에서, 비밀번호와 같은 민감한 정보를 제외한 나머지 정보만을 보여주는 뷰를 생성할 수 있다. 
  * 회원 테이블의 접근을 제한하고, 뷰를 통해서만 데이터를 조회 할 수 있도록 설정함으로써 보안을 강화할 수 있다.
* 복잡한 SQL을 단순하게 만들 수 있다.
  * 여러 테이블을 조인해서 복잡한 데이터를 자주 사용해야 한다면 뷰를 생성하여 복잡한 쿼리를 단순화할 수 있다.

## 8. 인덱스

### 장점
* 인덱스는 데이터베이스 테이블의 특정 열에 대한 검색 성능을 향상시키기 위해 사용되는 데이터 구조이다.
* 컴퓨터의 부담이 줄어들어서 전체 시스템의 성능이 향상된다.

### 단점
* 인덱스도 공간을 차지해서 데이터베이스 안에 추가적인 공간이 필요하다.
  * 인덱스는 대략 테이블의 크기의 10% 정도를 차지한다.
* 처음에 인덱스를 만드는데 시간이 걸린다.
* SELECT가 아닌 데이터의 변경 작업(INSERT, UPDATE, DELETE)이 자주 일어나면 오히려 성능이 나빠질 수 있다.

### 인덱스의 종류

* 클러스터형 인덱스
  * 기본 키로 지정하면 자동으로 클러스터형 인덱스가 생성된다.
    * 클러스터형 인덱스는 테이블에 한 개만 만들 수 있다.
  * 클러스터형 인덱스는 자동으로 정렬 되어 저장된다.
  
* 보조 인덱스
  * 고유키(UNIQUE)로 생성되는 인덱스는 보조 인덱스이다.
    * 기본 키와 더불어 고유 키(UNIQUE)도 인덱스가 자동으로 생성된다.
    * 별도의 공간에 인덱스를 생성한다.
  * 보조 인덱스는 정렬 되어 저장되지 않는다.
  * 보조 인덱스는 여러 개 만들 수 있지만 너무 많이 만들면 오히려 성능이 나빠질 수 있다.

## 9. 인덱스의 내부 작동
* 클러스터형 인덱스와 보조 인덱스는 모두 B-Tree(균형 트리) 구조로 저장된다.

### B-Tree 개념
* B-Tree 구조에서 데이터가 저장되는 공간을 `노드(Node)`라고 한다.
* Node는 Root Node, Internal Node, Leaf Node로 구성된다.
  * Root Node: 트리의 최상단 노드
  * Internal Node: 루트 노드와 리프 노드 사이에 있는 노드
  * Leaf Node: 트리의 가장 하단에 있는 노드로 실제 데이터가 저장되는 공간

### 페이지 개념
* 노드라는 용어는 개념적인 설명에서 주로 사용되며 실제 데이터베이스 내부에서는 `페이지(Page)`라는 용어를 사용한다.
* MySQL은 데이터를 페이지 단위로 관리한다.
* 페이지는 최소한의 저장 단위로, 16Kbyte 크기를 가진다.
  * 데이터를 1건만 저장하더라도 16Kbyte가 필요하다.

### 균형 트리
* 균형 트리는 무조건 `루트 페이지`부터 검색한다.
* 모든 데이터는 정렬되어 있다.
* 데이터 변경 작업(INSERT, UPDATE, DELETE)시 성능이 나빠진다.
  * 특히 INSERT 작업이 일어날 떄 더 느리다.
  * 이유는 `페이지 분할`이라는 작업이 발생하기 때문이다.
    * `페이지 분할`: 새로운 페이지를 준비해서 데이터를 나누는 작업을 말한다. 

### 보조 인덱스
* 보조인덱스는 데이터 페이지를 건드리지 않고 별도의 장소에 인덱스 페이지를 생성한다.
  * `데이터페이지`: 실제 데이터가 저장된 페이지
* 데이터의 위치는 `페이지 번호 +#위치`로 기록되어 있다.
  ![보조 인덱스 구조](https://blog.kakaocdn.net/dna/zXTRT/btqHoXCbpxL/AAAAAAAAAAAAAAAAAAAAAKsERRl33rtRHJq1XphRAgJ-fUVF-l3Ali7eyqqlz7n3/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1759244399&allow_ip=&allow_referer=&signature=0lJ2XTec4uagXVAmx4XBFX6JJqo%3D)
* 클러스터형 인덱스 하고 보조인덱스 중에서 클러스터형 인덱스가 조금 더 빠르다.
  * 이유는 클러스터형 인덱스는 데이터 페이지에 바로 접근하기 때문이다.
  * 보조 인덱스는 인덱스 페이지를 거쳐서 데이터 페이지에 접근하기 때문이다.

### 인덱스의 실제 사용
* CREATE TABLE INDEX 문을 사용하여 인덱스를 생성 했다면 생성한 인덱스를 실제로 적용시키려면 `ANALYZE TABLE` 문을 실행해야 한다.


* gender와 같은 이분법 컬럼은 단일 인덱스로 사용하지 않는 것이 좋다.
  * 이유는 인덱스가 적용되는 비율이 낮기 때문이다.
  * 예를 들어 1000건의 데이터 중에서 남자가 500건, 여자가 500건이라면 인덱스가 적용되는 비율이 50%이다.
  * 인덱스가 적용되는 비율이 낮으면 오히려 성능이 나빠질 수 있다.

  
* 인덱스가 있어도 MySQL이 인덱스 검색 보다는 풀 테이블 스캔을 선택할 수 있다.
  * MySQL이 인덱스 검색 보다는 풀 테이블 스캔이 더 빠르다고 판단할 수 있기 때문이다.


* 클러스터형 인덱스와 보조 인덱스가 섞여 있을 떄는 보조 인덱스를 먼저 제거하는 것이 좋다.
  * 클러스터형 인덱스를 먼저 제거해도 되지만 데이터를 쓸데없이 재구성해서 시간이 더 걸릴 수 있다.


### WHERE 문에서 열에 연산이 가해지면 인덱스를 사용할 수 없다.
```sql
SELECT mem_name, mem_number
    FROM member
    WHERE mem_number*2 >= 14;
```
-> 풀 테이블 스캔이 일어난다.
```sql
SELECT mem_name, mem_number
    FROM member
    WHERE mem_number >= 14/2;
```
-> 인덱스가 적용된다.
* 그러므로 WHERE 문에서는 열에 연산이 가해지지 않도록 한다.

## 인덱스를 효과적으로 사용하는 방법
### WHERE 문에서 자주 사용되는 열에 인덱스를 생성해라
-> SELECT 문을 사용할 떄 WHERE 절의 조건에 해당 열이 나와야 인덱스를 사용한다.

### WHERE 문에서 자주 사용해야 가치가 있다.
-> SELECT 문에서 1년에 1번 사용하고 INSERT 문에서 자주 사용되는 경우 성능에 악영향을 미친다.
* `페이지 분할` 작업이 일어나기 때문

### 데이터의 중복이 높은 열은 인덱스를 만들어도 효과가 없다. 
-> 열에 들어갈 데이터의 종류가 몇 가지 되지 않으면 인덱스를 만들어도 효과가 없다.
* 예를 들어 성별, 지역, 혈액형 등

### 클러스터형 인덱스는 테이블당 하나만 생성할 수 있다.
-> 기본 키로 지정하면 자동으로 클러스터형 인덱스가 생성된다.

-> 페이지를 읽는 수가 보조 인덱스보다 적기 때문에 성능이 더 좋다.

### 사용하지 않는 인덱스는 제거하자
-> 사용하지 않는 인덱스는 공간만 차지하고, 데이터 변경 작업(INSERT, UPDATE, DELETE)시 성능을 저하시킨다.